
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <title>Code Language Transformer</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0 auto; padding: 10px; }
        textarea { width: 100%; height: 200px; margin-bottom: 20px; padding: 10px; }
       

	  button {
    background-color: #4CAF50;
    color: white;
    padding: 6px 10px;
    border: none;
    border-radius: 22px;
    cursor: pointer;
}
	   button:hover { background-color: #45a049; }

.comparison-container {
    display: flex;
    margin-top: 1px;
    gap: 10px;
}


    .comparison-column {
    flex: 1;
    padding: 12px;
    border-radius: 11px;
    background-color: #ededed;
}
        .word-mapping { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
		
       .mapping-grid {
    display: grid;
    grid-template-columns: 1fr auto 1fr auto;
    gap: 1px;
    align-items: center;
    font-size: 15px;
}
		
		
        .mapping-header { font-weight: bold; background-color: #e9ecef; padding: 5px; border-radius: 3px; }
        .changed { color: #0066cc; font-weight: bold; }
        .unchanged { color: #888; }
        h3 { margin-top: 0; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
        .transformed-text { color: #28a745; font-weight: bold; }
        .option-code { font-weight: bold; color: #dc3545; }
        .loading { color: #6c757d; font-style: italic; }
		
		h1.titleh1 {
    color: #a95bff;
    font-size: 20px;
         }
		
	h3.titleh1 {
    color: #e3ac12;
    font-size: 19px;
               }
			   
		h4.titleh1 {
    color: #bc31f5;
    font-size: 17px;
               }		   
		h5.titleh1 {
    color: #178187;
    font-size: 16px;
               }		   
			   
			   
			   
			   
.col-sm-3 {
    background-color: #ffe7b6;
    border-radius: 9px;
    padding: 9px;
}	   
			   
			   
			   
		@media (min-width: 1200px){
			.container, .container-lg, .container-md, .container-sm, .container-xl {
				max-width: 1340px;}
         }
    </style>
</head>
<body>

<div class="container">
  <div class="row">
            <div class="col-sm-3">      
            
       

    <h1 class="titleh1">Code Language Transformer</h1>
    <p>Paste your code language questions below and click "Transform":</p>
    
    <textarea id="inputText" placeholder="Paste your questions here..."></textarea>
    
    <button onclick="transformQuestions()">Transform</button>
    <div id="loadingStatus" class="loading"></div>
    
    <div id="wordMappings" class="word-mapping"></div>
	
	</div>
     <div class="col-sm-9">      
       
    <div class="comparison-container">
        <div class="comparison-column">
            <h3 class="titleh1">Original Text</h3>
            <div id="originalOutput"></div>
        </div>
        <div class="comparison-column">
            <h3 class="titleh1">Transformed Text</h3>
            <div id="transformedOutput" class="transformed-text"></div>
        </div>
    </div>
	</div>
	</div> 
</div>  



<script>
 // Default fallback word bank with expanded categories
const defaultWordBank = {
  /*   general: ["can", "never", "follow", "maybe", "nor"],
    adjectives: ["sharp", "pointed", "keen", "edged", "piercing"],
    verbs: ["are", "is", "was", "were", "be", "stay", "come", "came"],
    adverbs: ["very", "extremely", "quite", "really", "highly"],
    pronouns: ["you", "they", "we", "he", "she", "it"],
    actions: ["coming", "going", "leaving", "arriving", "departing"],
    time: ["today", "tomorrow", "yesterday", "now", "soon"],
    states: ["stay", "remain", "wait", "pause", "halt"],
    descriptors: ["special", "unique", "particular", "specific", "distinct"],
    days: ["day", "date", "time", "moment", "occasion"], */
   
	nouns: ["knives", "swords"],
};

// Preserved keywords that should not be transformed
const preservedKeywords = new Set([
    "", "", ""
]);

// Global word bank reference
let activeWordBank = {};
let isWordBankLoaded = false;

async function loadWordBank() {
    console.log("Loading word bank...");
    document.getElementById('loadingStatus').textContent = "Loading word bank...";
    
    try {
        const response = await fetch('https://quiz.a-web.online/mock_test/take_test/wordBank.json');
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        
        const loadedBank = await response.json();
        
        // Validate and merge with defaults
        if (typeof loadedBank === 'object' && loadedBank !== null) {
            activeWordBank = {...defaultWordBank, ...loadedBank};
            console.log("Custom word bank loaded:", activeWordBank);
            document.getElementById('loadingStatus').textContent = "Custom word bank loaded!";
        } else {
            throw new Error("Invalid word bank format");
        }
    } catch (error) {
        console.warn("Using default word bank:", error);
        activeWordBank = defaultWordBank;
        document.getElementById('loadingStatus').textContent = "Using default word bank";
    } finally {
        isWordBankLoaded = true;
    }
}

// Initialize on page load
window.addEventListener('DOMContentLoaded', () => {
    loadWordBank().catch(error => {
        console.error("Word bank loading failed:", error);
        activeWordBank = defaultWordBank;
        isWordBankLoaded = true;
        document.getElementById('loadingStatus').textContent = "Using default word bank (error)";
    });
    
    setTimeout(() => {
        if (!isWordBankLoaded) {
            activeWordBank = defaultWordBank;
            isWordBankLoaded = true;
            document.getElementById('loadingStatus').textContent = "Using default word bank (timeout)";
        }
    }, 2000);
});

function generateRandomCode() {
    const letters = 'abcdefghijklmnopqrstuvwxyz';
    return letters.charAt(Math.floor(Math.random() * letters.length)) + 
           letters.charAt(Math.floor(Math.random() * letters.length));
}

function displayMappings(wordMappings, codeMappings) {
    const container = document.getElementById('wordMappings');
    let html = '<h4 class="titleh1">Transformation Mappings</h4>';
    
    // Word mappings
    html += '<h5 class="titleh1">Word Replacements:</h5><div class="mapping-grid">';
    html += '<div class="mapping-header">Original</div><div></div><div class="mapping-header">Replacement</div><div></div>';
    
    Object.entries(wordMappings).sort().forEach(([original, replacement]) => {
        const isChanged = original !== replacement;
        html += `
            <div class="${isChanged ? 'changed' : 'unchanged'}">${capitalizeFirstLetter(original)}</div>
            <div>→</div>
            <div class="${isChanged ? 'changed' : 'unchanged'}">${capitalizeFirstLetter(replacement)}</div>
            <div>${isChanged ? '' : '(no change)'}</div>
        `;
    });
    html += '</div>';
    
    // Code mappings
    html += '<h5 class="titleh1">Code Replacements:</h5><div class="mapping-grid">';
    html += '<div class="mapping-header">Original</div><div></div><div class="mapping-header">Replacement</div><div></div>';
    
    Object.entries(codeMappings).sort().forEach(([original, replacement]) => {
        const isChanged = original !== replacement;
        html += `
            <div class="${isChanged ? 'changed' : 'unchanged'}">${original}</div>
            <div>→</div>
            <div class="${isChanged ? 'changed' : 'unchanged'}">${replacement}</div>
            <div>${isChanged ? '' : '(no change)'}</div>
        `;
    });
    html += '</div>';
    
    container.innerHTML = html;
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}


function getRandomFromArray(array) {
    return array[Math.floor(Math.random() * array.length)];
}

function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}









/*

function transformQuestions() {

 // List of reserved phrases to skip (case insensitive)
    const reservedOptions = [
        "can't be determined",
        "either a or c", 
        "cannot be determined",
        "none of these",
        "either a or c",
        "either a or c",
        "either a or b"
    ];
	
    if (!isWordBankLoaded) {
        alert("Word bank is still loading. Please wait a moment and try again.");
        return;
    }

    const inputText = document.getElementById('inputText').value;
    if (!inputText.trim()) {
        alert('Please paste some questions first!');
        return;
    }

    const phraseRegex = /“(.*?)”\s+(?:means|as|coded as|coded|represents|change to|change as)\s+“(.*?)”/gi;
    const phraseMatches = [...inputText.matchAll(phraseRegex)];
    
    if (phraseMatches.length === 0) {
        alert('No code phrases found to transform!');
        return;
    }

    const wordMappings = {};
    const codeMappings = {};
    const usedCodes = new Set();
    const preservedPhrases = ["Can't be determined", "Either a or c", "Can't come determined"];

    // Generate random 2-letter code
    function generateTwoCharCode() {
        const letters = 'abcdefghijklmnopqrstuvwxyz';
        let code;
        do {
            code = '';
            for (let i = 0; i < 3; i++) {
                code += letters.charAt(Math.floor(Math.random() * letters.length));
            }
            // Ensure we don't get stuck in infinite loop
            if (usedCodes.size >= 676) { // 26*26 possible combinations
                code += Math.floor(Math.random() * 10); // Add number if we run out
            }
        } while (usedCodes.has(code));
        usedCodes.add(code);
        return code;
    }

    // Process all phrase matches
    phraseMatches.forEach(match => {
        // Transform left side words
        const words = match[1].toLowerCase().split(/\s+/);
        words.forEach(word => {
            if (!wordMappings[word]) {
                // Find replacement from word bank
                for (const category in activeWordBank) {
                    if (activeWordBank[category].includes(word)) {
                        let replacement;
                        do {
                            replacement = getRandomFromArray(activeWordBank[category]);
                        } while (replacement === word);
                        wordMappings[word] = replacement;
                        break;
                    }
                }
                // If not found in word bank, use random word
                if (!wordMappings[word]) {
                    const randomCategory = Object.keys(activeWordBank)[Math.floor(Math.random() * Object.keys(activeWordBank).length)];
                    wordMappings[word] = getRandomFromArray(activeWordBank[randomCategory]);
                }
            }
        });

        // Transform right side codes to new 2-character codes
        const codes = match[2].split(/\s+/);
        codes.forEach(code => {
            if (!codeMappings[code]) {
                codeMappings[code] = generateTwoCharCode();
            }
        });
    });

    // Transform the text
    let transformedText = inputText;
    
    // 1. Transform left side (words in quotes)
    transformedText = transformedText.replace(/“(.*?)”/g, (fullMatch, words) => {
        return '“' + words.split(/\s+/).map(word => {
            const lowerWord = word.toLowerCase();
            return wordMappings[lowerWord] ? 
                (word === word.toLowerCase() ? wordMappings[lowerWord] : capitalizeFirstLetter(wordMappings[lowerWord])) : 
                word;
        }).join(' ') + '”';
    });

transformedText = transformedText.replace(/“(.*?)”\s+(?:means|as|coded as|coded|represents|change to|change as)\s+“(.*?)”/gi, (fullMatch, leftWords, rightCodes) => {
    const newCodes = rightCodes.split(/\s+/).map(code => {
        // Return existing mapping if available
        if (codeMappings[code]) return codeMappings[code];
        
        // Generate new code based on type
        return /^\d+$/.test(code) 
            ? generateTwoDigitNumber().toString() 
            : generateTwoCharCode();
    }).join(' ');
    
    return `“${leftWords}” as “${newCodes}”`;
});

 // Generate random 2-digit number (10-99)
    function generateTwoDigitNumber() {
        return Math.floor(Math.random() * 90) + 10; // Range 10-99
    }

 // Process all phrase matches - updated to handle number codes
    phraseMatches.forEach(match => {
        // Left side words transformation (same as before)
        const words = match[1].toLowerCase().split(/\s+/);
        words.forEach(word => {
            if (!wordMappings[word]) {
                // ... [same word transformation logic as before]
            }
        });

        // Right side codes transformation - handle both letters and numbers
        const codes = match[2].split(/\s+/);
        codes.forEach(code => {
            if (!codeMappings[code]) {
                if (/^\d+$/.test(code)) {
                    // For number codes, generate new 2-digit number
                    codeMappings[code] = generateTwoDigitNumber().toString();
                } else {
                    // For letter codes, generate 2-letter code
                    codeMappings[code] = generateTwoCharCode();
                }
            }
        });
    });
	
    transformedText = transformedText.replace(/“(.*?)”\s+(?:means|as|coded as|coded|represents|change to|change as)\s+“(.*?)”/gi, (fullMatch, leftWords, rightCodes) => {
        const newCodes = rightCodes.split(/\s+/).map(code => 
            codeMappings[code] || 
            (/^\d+$/.test(code) ? generateTwoDigitNumber().toString() : generateTwoCharCode())
        ).join(' ');
        return `“${leftWords}” as “${newCodes}”`;
    });
	

    // 3. Transform options - skip reserved phrases but transform numbers
    transformedText = transformedText.replace(/([a-e])\.\s+(.+)/gi, (match, letter, optionText) => {
        // Check if option contains any reserved phrase
        const lowerOption = optionText.toLowerCase();
        const isReserved = reservedOptions.some(phrase => lowerOption.includes(phrase));
        
        if (!isReserved) {
            return `${letter}. ${optionText.split(/\s+/).map(part => {
                // Transform numbers (2+ digits)
                if (/^\d{2,}$/.test(part)) {
                    return generateTwoDigitNumber();
                }
                // Transform 2-letter codes
                else if (/^[a-z]{2}$/i.test(part)) {
                    return codeMappings[part] || generateTwoCharCode();
                }
                // Transform words (from word bank)
                else if (/^[a-z]+$/i.test(part)) {
                    const lowerWord = part.toLowerCase();
                    if (wordMappings[lowerWord]) {
                        return part === part.toLowerCase() ? 
                            wordMappings[lowerWord] : 
                            capitalizeFirstLetter(wordMappings[lowerWord]);
                    }
                }
                return part; // Return anything else unchanged
            }).join(' ')}`;
        }
        return match; // Return original if reserved
    });


// 4. Transform codes anywhere else in the text
    for (const [original, replacement] of Object.entries(codeMappings)) {
        const regex = new RegExp(`\\b${original}\\b`, 'gi');
        transformedText = transformedText.replace(regex, replacement);
    }

    // Update the display
    document.getElementById('originalOutput').innerHTML = inputText.replace(/\n/g, '<br>');
    document.getElementById('transformedOutput').innerHTML = transformedText.replace(/\n/g, '<br>');
    displayMappings(wordMappings, codeMappings);
}*/



function transformQuestions() {
    // List of reserved phrases to skip (case insensitive)
    const reservedOptions = [
        "can't be determined",
		"Can't be determined",
        "either a or c", 
        "cannot be determined",
        "none of these",
        "either a or c",
        "either a or c",
		"either b or c",
		"none of the above",
        "either a or b"
    ];
    
    if (!isWordBankLoaded) {
        alert("Word bank is still loading. Please wait a moment and try again.");
        return;
    }

    const inputText = document.getElementById('inputText').value;
    if (!inputText.trim()) {
        alert('Please paste some questions first!');
        return;
    }

  //const phraseRegex = /“(.*?)”\s+(?:means|as|coded as|coded|represents|change to|change as)\s+“(.*?)”/gi;
	
 const phraseRegex = /“(.*?)”\s+(?:means|is written as|is means|as||is coded as|coded as|coded|represents|change to|change as)\s+“(.*?)”/gi;
    const phraseMatches = [...inputText.matchAll(phraseRegex)];
    
    if (phraseMatches.length === 0) {
        alert('No code phrases found to transform!');
        return;
    }

    const wordMappings = {};
    const codeMappings = {};
    const usedCodes = new Set();
const numberMappings = {};
const usedNewNumbers = new Set();
    const preservedPhrases = ["Can't be determined", "Either a or c", "Can't come determined"];
	
        function getMappedNumber(originalNum) {
        if (!numberMappings[originalNum]) {
            let newNum;
            do {
                newNum = Math.floor(Math.random() * 90) + 10; // 10-99
            } while (Object.values(numberMappings).includes(newNum.toString()));
            numberMappings[originalNum] = newNum.toString();
        }
        return numberMappings[originalNum];
    }
	function getUniqueMappedNumber(originalNum) {
    // Return existing mapping if available
    if (numberMappings[originalNum]) {
        return numberMappings[originalNum];
    }
    
    // Generate new unique number
    let newNum;
    do {
        newNum = Math.floor(Math.random() * 90) + 10; // 10-99
    } while (usedNewNumbers.has(newNum));
    
    // Store the mapping
    numberMappings[originalNum] = newNum.toString();
    usedNewNumbers.add(newNum);
    
    return newNum.toString();
}
	
	
	
	
    // Generate random 3-letter code
    function generateTwoCharCode() {
        const letters = 'abcdefghijklmnopqrstuvwxyz';
        let code;
        do {
            code = '';
            for (let i = 0; i < 2; i++) { // Changed to 2,3,4, characters
                code += letters.charAt(Math.floor(Math.random() * letters.length));
            }
            if (usedCodes.size >= 676) { // 26*26 possible combinations
                code += Math.floor(Math.random() * 10);
            }
        } while (usedCodes.has(code));
        usedCodes.add(code);
        return code;
    }

    // Generate random 2-digit number (10-99)
    function generateTwoDigitNumber() {
        return Math.floor(Math.random() * 90) + 10;
    }

    // Process all phrase matches
    phraseMatches.forEach(match => {
        // Transform left side words
        const words = match[1].toLowerCase().split(/\s+/);
        words.forEach(word => {
            if (!wordMappings[word]) {
                for (const category in activeWordBank) {
                    if (activeWordBank[category].includes(word)) {
                        let replacement;
                        do {
                            replacement = getRandomFromArray(activeWordBank[category]);
                        } while (replacement === word);
                        wordMappings[word] = replacement;
                        break;
                    }
                }
                if (!wordMappings[word]) {
                    const randomCategory = Object.keys(activeWordBank)[Math.floor(Math.random() * Object.keys(activeWordBank).length)];
                    wordMappings[word] = getRandomFromArray(activeWordBank[randomCategory]);
                }
            }
        });



// In your transformation code:
phraseMatches.forEach(match => {
    const codes = match[2].split(/\s+/);
    codes.forEach(code => {
        if (!codeMappings[code]) {
            codeMappings[code] = /^\d+$/.test(code) 
                ? getUniqueMappedNumber(code) 
                : generateTwoCharCode();
        }
    });
});
        // Transform right side codes
        const codes = match[2].split(/\s+/);
        /*codes.forEach(code => {
            if (!codeMappings[code]) {
                codeMappings[code] = /^\d+$/.test(code) 
                    ? generateTwoDigitNumber().toString() 
                    : generateTwoCharCode();
            }
        }); */
		codes.forEach(code => {
            if (!codeMappings[code]) {
                if (/^\d+$/.test(code)) {
                    codeMappings[code] = getMappedNumber(code);
                } else {
                    codeMappings[code] = generateTwoCharCode();
                }
            }
        });
		
		
    });

    let transformedText = inputText;
    
    // 1. Transform left side (words in quotes)
    transformedText = transformedText.replace(/“(.*?)”/g, (fullMatch, words) => {
        return '“' + words.split(/\s+/).map(word => {
            const lowerWord = word.toLowerCase();
            return wordMappings[lowerWord] ? 
                (word === word.toLowerCase() ? wordMappings[lowerWord] : capitalizeFirstLetter(wordMappings[lowerWord])) : 
                word;
        }).join(' ') + '”';
    });

    // 2. Transform right side codes
    transformedText = transformedText.replace(/“(.*?)”\s+(?:means|as|coded as|coded|represents|change to|change as)\s+“(.*?)”/gi, (fullMatch, leftWords, rightCodes) => {
        const newCodes = rightCodes.split(/\s+/).map(code => codeMappings[code]).join(' ');
        return `“${leftWords}” as “${newCodes}”`;
    });

    // 3. Transform options
    transformedText = transformedText.replace(/([a-e])\.\s+(.+)/gi, (match, letter, optionText) => {
        const lowerOption = optionText.toLowerCase();
        const isReserved = reservedOptions.some(phrase => lowerOption.includes(phrase));
        
        if (!isReserved) {
            return `${letter}. ${optionText.split(/\s+/).map(part => {
                if (/^\d{2,}$/.test(part)) {
                    return generateTwoDigitNumber();
                }
                else if (/^[a-z]{2}$/i.test(part)) {
                    return codeMappings[part] || generateTwoCharCode();
                }
                else if (/^[a-z]+$/i.test(part)) {
                    const lowerWord = part.toLowerCase();
                    if (wordMappings[lowerWord]) {
                        return part === part.toLowerCase() ? 
                            wordMappings[lowerWord] : 
                            capitalizeFirstLetter(wordMappings[lowerWord]);
                    }
                }
                return part;
            }).join(' ')}`;
        }
        return match;
    });

    // 4. Transform remaining codes
    for (const [original, replacement] of Object.entries(codeMappings)) {
        const regex = new RegExp(`\\b${original}\\b`, 'gi');
        transformedText = transformedText.replace(regex, replacement);
    }

    // Update the display
    document.getElementById('originalOutput').innerHTML = inputText.replace(/\n/g, '<br>');
    document.getElementById('transformedOutput').innerHTML = transformedText.replace(/\n/g, '<br>');
    displayMappings(wordMappings, codeMappings);
}
</script>
</body>
</html>
